#ifndef LIBRARY_DL
#define LIBRARY_DL
// ===============================================================

// -----
// Types
// -----
.type Statement
.type Variable
.type Operand

// ------
// Inputs
// ------
.decl start(stmt:Statement) input
.decl end(stmt:Statement) input
.decl edge(u:Statement, v:Statement) input           // A connection between two statements
.decl write(stmt:Statement, var:Variable) input    // Assignment of a TAC variable
.decl read(stmt:Statement, var:Variable) input       // Use of a TAC variable in some operation
.decl op(stmt:Statement, op:Operand) input           // A TAC operand {_, EQ, JUMP, JUMPI}

// ---------------
// Basic relations
// ---------------

// Interpret as: the reverse edge of d to s
.decl r_edge(s:Statement, d:Statement)
r_edge(s, d) :- edge(d, s).

.decl node(stmt:Statement)
node(x) :- edge(x, _).
node(x) :- edge(_, x).

// Interpret as: there is a path from u to v
.decl path(u:Statement, v:Statement)
path(u,v) :- edge(u,v).
path(u,v) :- edge(u,w), path(w,v).

// Interpret as: y is a successor of x
.decl successor(x:Statement, y:Statement)
successor(x, y) :- edge(x, y).

.decl successor_size(x:Statement, s:number)
successor_size(x, 0) :- node(x), !edge(x, _).
successor_size(x, s) :- edge(x, _), s = count : edge(x, _).

// Interpret as: y is a predecessor of x
.decl predecessor(x:Statement, y:Statement)
predecessor(x, y) :- r_edge(x, y).

.decl predecessor_size(x:Statement, s:number)
predecessor_size(x, 0) :- node(x), !edge(_, x).
predecessor_size(x, s) :- edge(_, x), s = count : edge(_, x).

.decl usedBy(x:Variable, y:Variable)
usedBy(x, y) :- read(stmt, x), write(stmt, y).

.decl usedFor(x:Variable, z:Variable)
usedFor(x, x) :- usedBy(x, _).
usedFor(x, x) :- usedBy(_, x).
usedFor(x, z) :- usedBy(x, z).
usedFor(x, z) :- usedBy(x, y), usedFor(y, z).

.decl controls(x:Statement, y:Statement)
controls(x, y) :- pdomBy(w1, y), successor(x, w1), !pdomBy(w2, y), successor(x, w2).
controls(x, z) :- controls(x, y), controls(y, z).

// ===============================================================

// -------------------
// Dominance relations
// -------------------
// Note: dom(s, d) => s is dominated by d

.decl non_dom(s:Statement, d:Statement)
non_dom(x, y) :- start(x), node(y), x != y.
non_dom(x, y) :- non_dom(z, y), edge(z, x), !start(x), x != y .

.decl dom(s:Statement, d:Statement)
dom(x, y) :- node(x), node(y), !non_dom(x, y).

.decl s_dom(n:Statement, d:Statement)
s_dom(n, d) :- dom(n, d), n != d.

// -----------------------------
// Immediate Dominance relations
// -----------------------------

.decl s_domsize(n:Statement, s:number)
s_domsize(n, 0) :- start(n).
s_domsize(n, s) :- s_dom(n, _), s = count : s_dom(n, _).

.decl s_domsizes(n:Statement, d:Statement, m:number)
s_domsizes(n, d, s) :- s_dom(n, d), s_domsize(d, s).

.decl s_max_domsize(n:Statement, s:number)
s_max_domsize(n, 0) :- start(n).
s_max_domsize(n, y) :- s_domsizes(n, _, _), y = max s : s_domsizes(n, _, s).

.decl imdom(n:Statement, i:Statement)
imdom(n, x) :- s_dom(n, x), s_domsize(x, s), s_max_domsize(n, s).

// ------------------------
// Post-Dominance relations
// ------------------------
// Note: pdom(s, d) => s is post-dominated by d.
// It also assumes that there is a single end node (singleton).
// In other words, that the dominators in the reverse cfg => post-dominators

.decl non_pdomBy(s:Statement, d:Statement)
non_pdomBy(x, y) :- end(x), node(y), x != y.
non_pdomBy(x, y) :- non_pdomBy(z, y), r_edge(z, x), !end(x), x != y .

.decl pdomBy(s:Statement, d:Statement)
pdomBy(x, y) :- node(x), node(y), !non_pdomBy(x, y).

.decl s_pdomBy(n:Statement, d:Statement)
s_pdomBy(n, d) :- pdomBy(n, d), n != d.

// -----------------------------
// Immediate Post-Dominance relations
// -----------------------------

.decl s_pdomsize(n:Statement, s:number)
s_pdomsize(n, 0) :- end(n).
s_pdomsize(n, s) :- s_pdomBy(n, _), s = count : s_pdomBy(n, _).

.decl s_pdomsizes(n:Statement, d:Statement, m:number)
s_pdomsizes(n, d, s) :- s_pdomBy(n, d), s_pdomsize(d, s).

.decl s_max_pdomsize(n:Statement, s:number)
s_max_pdomsize(n, 0) :- end(n).
s_max_pdomsize(n, y) :- s_pdomsizes(n, _, _), y = max s : s_pdomsizes(n, _, s).

.decl impdomBy(n:Statement, i:Statement)
impdomBy(n, x) :- s_pdomBy(n, x), s_pdomsize(x, s), s_max_pdomsize(n, s).

// ===============================================================
#endif
