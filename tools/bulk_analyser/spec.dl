// BSD 3-Clause License
//
// Copyright (c) 2016, 2017, The University of Sydney. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// * Redistributions of source code must retain the above copyright notice, this
//   list of conditions and the following disclaimer.
//
// * Redistributions in binary form must reproduce the above copyright notice,
//   this list of conditions and the following disclaimer in the documentation
//   and/or other materials provided with the distribution.
//
// * Neither the name of the copyright holder nor the names of its
//   contributors may be used to endorse or promote products derived from
//   this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#include "unstructured_loop_detector.dl"

.type Statement
.type Variable
.type Opcode
.type Value
.type Block
      
// INPUT

.decl edge(h:Statement, t:Statement)                // There is a CFG edge from h to t
.input edge
.decl def(var:Variable, stmt:Statement)             // var is defined by stmt
.input def
.decl use(var:Variable, stmt:Statement, i:number)   // var is used by stmt as argument i
.input use
.decl op(stmt:Statement, op:Opcode)                 // stmt's opcode is op
.input op
.decl value(var:Variable, val:Value)                // A variable's possible value set if known
.input value
.decl isBlock(b: Block)
.decl block(s: Statement, b: Block)
.input block

isBlock(b) :- block(_, b).

       
// Requires dominator, CALL, JUMPI, SSTORE relations.
.decl op_CALL(stmt:Statement, gas:Variable, target:Variable, value:Variable, data_start:Variable, data_length:Variable, return_start:Variable, return_length:Variable)
.input op_CALL
.decl op_JUMPI(stmt:Statement, dest:Variable, cond:Variable)
.input op_JUMPI
.decl op_SSTORE(stmt:Statement, loc:Variable, val:Variable)
.input op_SSTORE


// Place opcodes into various categories.
.decl unaryArith(opcode:Opcode)
unaryArith("ISZERO").
unaryArith("NOT").

.decl binArith(opcode:Opcode)
binArith("ADD").
binArith("MUL").
binArith("SUB").
binArith("DIV").
binArith("SDIV").
binArith("MOD").
binArith("SMOD").
binArith("EXP").
binArith("SIGNEXTEND").
binArith("LT").
binArith("GT").
binArith("SLT").
binArith("SGT").
binArith("EQ").
binArith("AND").
binArith("OR").
binArith("XOR").
binArith("BYTE").

.decl ternArith(opcode:Opcode)
ternArith("ADDMOD").
ternArith("MULMOD").

.decl runtimeKnowable(opcode:Opcode)
runtimeKnowable("ADDRESS").
runtimeKnowable("ORIGIN").
runtimeKnowable("CALLER").
runtimeKnowable("CALLVALUE").
runtimeKnowable("CALLDATASIZE").
runtimeKnowable("CODESIZE").
runtimeKnowable("GASPRICE").

.decl isThrow(stmt:Statement)
isThrow(stmt) :- op(stmt, "THROW").
isThrow(stmt) :- op(stmt, "THROWI").


// The value of x depends on the value of y
// I.e. y is used to calculate x, either directly as an input of the operation
// that defined x, or transitively.
.decl depends(x:Variable, y:Variable)
depends(x, x) :- use(x, _, _).
depends(x, x) :- def(x, _).
depends(x, y) :- def(x, stmt), use(y, stmt, _).
depends(x, z) :- depends(x, y), depends(y, z).


// Basic concepts: entry/exit, basic blocks

.decl Entry(s:Statement)
.decl Exit(s:Statement)
.decl IsStatement(s:Statement)

.output Entry

IsStatement(s) :- op(s, _).

Entry(s) :- IsStatement(s), !edge(_,s).
Exit(s) :- IsStatement(s), !edge(s,_).

.decl IsJump(s:Statement)
IsJump(s) :- op(s, "JUMP").
IsJump(s) :- op(s, "JUMPI").

.decl JumpTarget(s:Statement)
JumpTarget(s) :- op(s, "JUMPDEST").

.decl BasicBlockBegin(s:Statement)
BasicBlockBegin(s) :- Entry(s).
BasicBlockBegin(s) :- JumpTarget(s).

.decl NextInSameBasicBlock(s:Statement, next:Statement)
NextInSameBasicBlock(s,next) :-
  edge(s,next), !BasicBlockBegin(next).
NextInSameBasicBlock(s,next) :-
  BasicBlockHead(s,next), edge(s,next).

.decl BasicBlockHead(s:Statement, head:Statement)
BasicBlockHead(s,s) :- BasicBlockBegin(s).
BasicBlockHead(s,h) :- BasicBlockHead(prev,h), NextInSameBasicBlock(prev,s).
 .plan 1:(2,1)


.output BasicBlockHead

// Reachability and Dominance

.decl CanReach(s:Statement, t:Statement)

CanReach(s,s) :- IsStatement(s).
CanReach(s,t) :- edge(s,t).
CanReach(s,t) :- CanReach(s,v), edge(v,t).


//// ASSERTION
.decl AssertStatementsReachable(s:Statement)
.output AssertStatementsReachable
.decl HelperStatementsReachable(s:Statement)
// there may be multiple entries
HelperStatementsReachable(s) :-
  CanReach(entry,s), Entry(entry).

AssertStatementsReachable(s) :-
  IsStatement(s), !HelperStatementsReachable(s).


// defined on basic blocks, identified by their first instruction
.decl SuccessorBB(next:Statement, prev:Statement)
SuccessorBB(next,prev) :-
  BasicBlockHead(exitNode, prev),
  edge(exitNode,next).

.decl PredecessorBB(prev:Statement, next:Statement)
PredecessorBB(prev,next) :-
  SuccessorBB(next,prev).


        //// ASSERTION
        .decl AssertSuccessorWellDefined(s:Statement)
	    .output AssertSuccessorWellDefined
        AssertSuccessorWellDefined(s) :- SuccessorBB(s,_), !BasicBlockHead(_,s).


// Both arguments are basic block heads
// There is a path from the entry to s that does not go through candidate
.decl DoesNotDominate(candidate:Statement, s:Statement)
DoesNotDominate(candidate,s) :-
  Entry(s),
  BasicBlockHead(_, candidate).

DoesNotDominate(candidate,s) :-
  DoesNotDominate(candidate,other),
  SuccessorBB(s,other),
  s != candidate.

// Both arguments are basic block heads
// There is a path from s to the exit that does not go through candidate
.decl DoesNotPostDominate(candidate:Statement, s:Statement)
DoesNotPostDominate(candidate,s) :-
  Exit(exitNode),
  BasicBlockHead(exitNode,s),
  BasicBlockHead(_, candidate).

DoesNotPostDominate(candidate,s) :-
  DoesNotPostDominate(candidate,other),
  SuccessorBB(other,s),
  s != candidate.

// The Dominates/PostDominates relation is defined on basic blocks,
// represented by their first instruction (head). Defining
// a dense quadratic relation, like Dominates, on individual
// instructions would be expensive.
.decl Dominates(dominator:Statement, s:Statement)
Dominates(dominator,s) :-
  BasicBlockHead(_, dominator),
  BasicBlockHead(_, s),
  !DoesNotDominate(dominator,s).

.output Dominates

.decl PostDominates(postdominator:Statement, s:Statement)
PostDominates(postdominator,s) :-
  BasicBlockHead(_, postdominator),
  BasicBlockHead(_, s),
  !DoesNotPostDominate(postdominator,s).

.output PostDominates


//// Recognize structured loops

.decl StructuredLoopBackEdge(from:Statement, to:Statement)
.decl StructuredLoopHead(s:Statement)

StructuredLoopBackEdge(from,to),
StructuredLoopHead(to) :-
  edge(from,to),
  BasicBlockHead(from,h),
  Dominates(to,h).

// Detect a loop body *without* also capturing surrounding loops (i.e., not just SCC)
.decl InStructuredLoop(s:Statement, loophead:Statement)
InStructuredLoop(backEdgeNode,loophead) :- StructuredLoopBackEdge(backEdgeNode,loophead).
InStructuredLoop(loophead,loophead) :- StructuredLoopHead(loophead).
// Can reach back edge node without going through loop head!
InStructuredLoop(s,loophead) :-
  InStructuredLoop(other,loophead),
  edge(s,other),
  other != loophead.

.output StructuredLoopHead
.output InStructuredLoop

.decl ContainsInnerStructuredLoop(loophead:Statement,innerLoopHead:Statement)
ContainsInnerStructuredLoop(loophead,innerLoopHead) :-
  StructuredLoopHead(loophead),
  StructuredLoopHead(innerLoopHead),
  InStructuredLoop(innerLoopHead,loophead),
  innerLoopHead != loophead.
  
.decl InnermostStructuredLoop(loophead:Statement)
InnermostStructuredLoop(loophead) :-
  StructuredLoopHead(loophead),
  !ContainsInnerStructuredLoop(loophead,_).

.output InnermostStructuredLoop

// The most general definition of a loop-like structure: in same SCC
.decl InLoop(s:Statement, t:Statement)
InLoop(s,t) :-
  CanReach(s,t),
  CanReach(t,s),
  s != t.

//// ASSERTION
.decl AssertLoopsAreStructured(s:Statement)
.output AssertLoopsAreStructured
AssertLoopsAreStructured(h) :-
  BasicBlockHead(_,h),
  InLoop(h,_),
  !InStructuredLoop(h,_).


// var is the result of a SLOAD operation, stmt
.decl sloadResult(var:Variable, stmt:Statement)
sloadResult(var, stmt) :- op(stmt, "SLOAD"), def(var, stmt).

// var is the result of a CALL operation, stmt
.decl callStmt(stmt:Statement)
callStmt( stmt) :- op(stmt, "CALL").
callStmt( stmt) :- op(stmt, "CALLCODE").
callStmt( stmt) :- op(stmt, "DELEGATECALL").
callStmt( stmt) :- op(stmt, "STATICCALL").


// var is the result of a SSTORE operation, stmt
.decl sstoreStmt(stmt:Statement)
sstoreStmt( stmt) :- op(stmt, "SSTORE").

.decl LoopExitCond(cond: Variable, x: Statement)
      
LoopExitCond(cond, x) :-
  op(jmpi, "JUMPI"), // TODO: only predicate
  use(cond, jmpi, 0),
  InStructuredLoop(jmpi, x),
  edge(jmpi, out),
  !InStructuredLoop(out, x).
      
.decl dynamicBound(x:Statement)
.output dynamicBound
        
dynamicBound(x) :-
  InStructuredLoop(sloadStmt, x),
  sloadResult(resVar, sloadStmt),
  LoopExitCond(cond, x),
  depends(cond, resVar).

// TODO: too conservative, improve by
// a) Checking whether loop is statically bound
// b) Check reentrancy monotonicity
.decl checkedWalletGriefing(x:Statement)
.output checkedWalletGriefing      
checkedWalletGriefing(callStmt) :- InStructuredLoop(callStmt, _), callStmt(callStmt).


// TODO: too conservative, improve by
// a) Checking whether looping on data structure
// b) Data structure monotonic increase in size
.decl checkedMassSSTORE(x:Statement)
.output checkedMassSSTORE
checkedMassSSTORE(x) :- InStructuredLoop(sstoreStmt, x), sstoreStmt(sstoreStmt).

/*

// UNSECURED BALANCE

.decl fromCallValue(var:Variable)
fromCallValue(var) :- depends(var, callValVar), def(callValVar, callValStmt), op(callValStmt, "CALLVALUE").
.decl usefulValue(var:Variable)
usefulValue(var) :- !value(var, "0x0"), !fromCallValue(var), def(var, _).

// A call statement satisfies this relation if its target can be manipulated (and is not constant), it actually sends some value, and it's actually callable.
.decl unsecuredValueSend(stmt:Statement)
.output unsecuredValueSend
unsecuredValueSend(stmt) :- op_CALL(stmt, _, target, val, _, _, _, _), nonConstManipulable(target), usefulValue(val), !inaccessible(stmt).

// SUICIDE
.decl accessibleSuicide(stmt:Statement)
.output accessibleSuicide
accessibleSuicide(stmt) :- !inaccessible(stmt), op(stmt, "SUICIDE").

*/